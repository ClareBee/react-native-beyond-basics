(self.webpackChunkreact_native_beyond_basics=self.webpackChunkreact_native_beyond_basics||[]).push([[31],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,l=d(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,y=u["".concat(s,".").concat(m)]||u[m]||c[m]||o;return n?a.createElement(y,i(i({ref:t},l),{},{components:n})):a.createElement(y,i({ref:t},l))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var d={};for(var s in t)hasOwnProperty.call(t,s)&&(d[s]=t[s]);d.originalType=e,d.mdxType="string"==typeof e?e:r,i[1]=d;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3919:function(e,t,n){"use strict";function a(e){return!0===/^(\w*:|\/\/)/.test(e)}function r(e){return void 0!==e&&!a(e)}n.d(t,{b:function(){return a},Z:function(){return r}})},4996:function(e,t,n){"use strict";n.d(t,{C:function(){return o},Z:function(){return i}});var a=n(2263),r=n(3919);function o(){var e=(0,a.default)().siteConfig,t=(e=void 0===e?{}:e).baseUrl,n=void 0===t?"/":t,o=e.url;return{withBaseUrl:function(e,t){return function(e,t,n,a){var o=void 0===a?{}:a,i=o.forcePrependBaseUrl,d=void 0!==i&&i,s=o.absolute,p=void 0!==s&&s;if(!n)return n;if(n.startsWith("#"))return n;if((0,r.b)(n))return n;if(d)return t+n;var l=n.startsWith(t)?n:t+n.replace(/^\//,"");return p?e+l:l}(o,n,e,t)}}}function i(e,t){return void 0===t&&(t={}),(0,o().withBaseUrl)(e,t)}},6760:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return d},metadata:function(){return s},toc:function(){return p},default:function(){return c}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),i=n(4996),d={sidebar_position:13},s={unversionedId:"animated-drawer",id:"animated-drawer",isDocsHomePage:!1,title:"Layout Animation",description:"In our app, the user is able to record their current mood multiple times a day. Let's group these records by day.",source:"@site/docs/animated-drawer.mdx",sourceDirName:".",slug:"/animated-drawer",permalink:"/react-native-beyond-basics/docs/animated-drawer",editUrl:"https://github.com/kadikraman/react-native-beyond-basics/edit/main/website/docs/animated-drawer.mdx",version:"current",sidebarPosition:13,frontMatter:{sidebar_position:13},sidebar:"tutorialSidebar",previous:{title:"App Icons",permalink:"/react-native-beyond-basics/docs/app-icons"},next:{title:"Gestures and Animation",permalink:"/react-native-beyond-basics/docs/gestures"}},p=[{value:"Grouping entries by day",id:"grouping-entries-by-day",children:[]},{value:"Checkpoint \ud83d\udd17",id:"checkpoint-",children:[]},{value:"Create a Drawer component",id:"create-a-drawer-component",children:[]},{value:"Animate the drawer opening",id:"animate-the-drawer-opening",children:[]},{value:"Checkpoint \ud83d\udd17",id:"checkpoint--1",children:[]}],l={toc:p};function c(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In our app, the user is able to record their current mood multiple times a day. Let's group these records by day."),(0,o.kt)("p",null,'A tip: in order to create "old" data, set your computer clock in the past and add some moods.'),(0,o.kt)("h2",{id:"grouping-entries-by-day"},"Grouping entries by day"),(0,o.kt)("p",null,"Let's start by getting the data in order and group the entries by day."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://lodash.com/"},"Lodash")," is a handy library for doing data manipulation. It's JavaScript-only, meaning no native code."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"yarn add lodash\n")),(0,o.kt)("p",null,"For lodash, we'll also need to add the types separately:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"yarn add @types/lodash --dev\n")),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"HistoryTab.screen.tsx")," component, let's convert our days array into the appropriate format. First, ensure the days are in the right order:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'import orderBy from "lodash/orderBy";\n\nconst ordered = orderBy(moodList, "timestamp", "desc");\n')),(0,o.kt)("p",null,"Next, let's use ",(0,o.kt)("inlineCode",{parentName:"p"},"groupBy")," to group the items by day:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'import groupBy from "lodash/groupBy";\n\nconst grouped = groupBy(ordered, (item) =>\n  format(new Date(item.timestamp), "dd MMM, yyyy")\n);\n')),(0,o.kt)("p",null,"Now, map over the object so we end up with an array of days with a sub-array of moods:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const days = Object.entries(grouped).map(([day, moodsInDay]) => ({\n  day,\n  moodsInDay,\n}));\n")),(0,o.kt)("p",null,"Finally, we can wrap the whole thing in ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," to ensure the calculation in only re-run when necessary:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const days = useMemo(() => {\n  const ordered = orderBy(moodList, "timestamp", "desc");\n\n  const grouped = groupBy(ordered, (item) =>\n    format(new Date(item.timestamp), "dd MMM, yyyy")\n  );\n\n  return Object.entries(grouped).map(([day, moodsInDay]) => ({\n    day,\n    moodsInDay,\n  }));\n}, [moodList]);\n')),(0,o.kt)("p",null,"Now let's render the days using a FlatList:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"<FlatList\n  keyExtractor={(item) => item.day}\n  data={days}\n  renderItem={({ item }) => (\n    <View>\n      <Text>{item.day}</Text>\n      {item.moodsInDay.map((mood: MoodOptionWithTimestamp) => (\n        <MoodItemRow item={mood} key={mood.timestamp} />\n      ))}\n    </View>\n  )}\n/>\n")),(0,o.kt)("h2",{id:"checkpoint-"},"Checkpoint \ud83d\udd17"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/kadikraman/mood-tracker/commit/d7ed9f9150604940a18b2f2ebbe213594037f02f"},(0,o.kt)("strong",{parentName:"a"},"Group entries by day in sections")," d7ed9f9150604940a18b2f2ebbe213594037f02f")),(0,o.kt)("h2",{id:"create-a-drawer-component"},"Create a Drawer component"),(0,o.kt)("p",null,"Let's refactor each day into a ",(0,o.kt)("inlineCode",{parentName:"p"},"Drawer")," component: it should have a heading and items. The heading should be pressable so that pressing the heading will reveal or hide the items."),(0,o.kt)("h2",{id:"animate-the-drawer-opening"},"Animate the drawer opening"),(0,o.kt)("p",null,"We can use ",(0,o.kt)("a",{parentName:"p",href:"https://reactnative.dev/docs/layoutanimation"},"LayoutAnimation")," to animate the drawers open and close."),(0,o.kt)("p",null,"LayoutAnimation is incredibly powerful, although not very flexible - essentially, when you trigger a layout animation, it will automatically animate the ",(0,o.kt)("em",{parentName:"p"},"next")," UI update using the animation configuration. It can't be used for complex or intricate animations, but for our drawer example, it's perfect."),(0,o.kt)("p",null,"For Android, we need to first enable LayoutAnimation, since it's still an experimental feature. In open ",(0,o.kt)("inlineCode",{parentName:"p"},"App.tsx")," and add:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'import { Platform, UIManager } from "react-native";\n\nif (Platform.OS === "android") {\n  if (UIManager.setLayoutAnimationEnabledExperimental) {\n    UIManager.setLayoutAnimationEnabledExperimental(true);\n  }\n}\n')),(0,o.kt)("p",null,"To trigger a layout animation, add it just before ",(0,o.kt)("inlineCode",{parentName:"p"},"setIsOpen")," gets called:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff"},'+import { LayoutAnimation } from "react-native";\n\nconst handleToggleOpen = React.useCallback(() => {\n+  LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);\n  setIsOpen(val => !val);\n}, []);\n')),(0,o.kt)("h2",{id:"checkpoint--1"},"Checkpoint \ud83d\udd17"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/kadikraman/mood-tracker/commit/9f4a5333e0b479d91b29c4f8a106a671242f7039"},(0,o.kt)("strong",{parentName:"a"},"Add an animated drawer")," 9f4a5333e0b479d91b29c4f8a106a671242f7039")),(0,o.kt)("img",{src:(0,i.Z)("/img/animated-drawer/ios.png"),alt:"iOS animated drawer",width:"50%"}),(0,o.kt)("img",{src:(0,i.Z)("/img/animated-drawer/android.png"),alt:"Android animated drawer",width:"50%"}))}c.isMDXComponent=!0}}]);