(self.webpackChunkreact_native_beyond_basics=self.webpackChunkreact_native_beyond_basics||[]).push([[377],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,y=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?r.createElement(y,o(o({ref:t},l),{},{components:n})):r.createElement(y,o({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6577:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},metadata:function(){return p},toc:function(){return s},default:function(){return l}});var r=n(2122),a=n(9756),i=(n(7294),n(3905)),o={sidebar_position:2},p={unversionedId:"typescript",id:"typescript",isDocsHomePage:!1,title:"Into to TypeScript",description:"You would have noticed that when creating the new project, we used the React Native TypeScript template. That's because we will indeed be building our app in TypeScript.",source:"@site/docs/typescript.md",sourceDirName:".",slug:"/typescript",permalink:"/react-native-beyond-basics/docs/typescript",editUrl:"https://github.com/kadikraman/react-native-beyond-basics/edit/main/website/docs/typescript.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Welcome",permalink:"/react-native-beyond-basics/docs/welcome"},next:{title:"New Project",permalink:"/react-native-beyond-basics/docs/new-project"}},s=[{value:"What is TypeScript",id:"what-is-typescript",children:[{value:"1. Static Code Analysis",id:"1-static-code-analysis",children:[]},{value:"2. Expand JavaScript with Custom Types",id:"2-expand-javascript-with-custom-types",children:[]}]},{value:"Checking for type errors",id:"checking-for-type-errors",children:[]},{value:"Typing React Components",id:"typing-react-components",children:[{value:"In JavaScript:",id:"in-javascript",children:[]},{value:"In TypeScript:",id:"in-typescript",children:[]}]},{value:"Typing React Component Props",id:"typing-react-component-props",children:[]}],c={toc:s};function l(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You would have noticed that when creating the new project, we used the React Native TypeScript template. That's because we will indeed be building our app in TypeScript."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play"},"https://www.typescriptlang.org/play")),(0,i.kt)("h2",{id:"what-is-typescript"},"What is TypeScript"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript"),' is essentially "typed JavaScript". It is a superset of JavaScript, which means that all valid JavaScript code is also valid TypeScript code. TypeScript files in React Native have ',(0,i.kt)("inlineCode",{parentName:"p"},".ts")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".tsx")," file extensions (instead of ",(0,i.kt)("inlineCode",{parentName:"p"},".js")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".jsx"),")."),(0,i.kt)("p",null,"TypeScript has two main usages:"),(0,i.kt)("h3",{id:"1-static-code-analysis"},"1. Static Code Analysis"),(0,i.kt)("p",null,"It analyses your existing code and points out any incorrect usages when possible."),(0,i.kt)("p",null,"For example, consider the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const myNum = 5;\nmyNum.split("");\n')),(0,i.kt)("p",null,"If you try this in a TypeScript file in your code editor, you should get a red underline under ",(0,i.kt)("inlineCode",{parentName:"p"},"split")," with the following message:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Property 'split' does not exist on type '5'.ts(2339)")),(0,i.kt)("p",null,"TypeScript has noticed that ",(0,i.kt)("inlineCode",{parentName:"p"},"myNum")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", but the ",(0,i.kt)("inlineCode",{parentName:"p"},"split")," method can only be called on ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," types which will most certainly cause an error if we try to run this code."),(0,i.kt)("h3",{id:"2-expand-javascript-with-custom-types"},"2. Expand JavaScript with Custom Types"),(0,i.kt)("p",null,"You can also declare types for your code to communicate intent and stay type safe. For example, consider this functions that is designed for adding two numbers together:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="add.js"',title:'"add.js"'},"const add = (a, b) => a + b;\n")),(0,i.kt)("p",null,"Since JavaScript is not type safe, there is really nothing preventing (or even warning you) from passing in strings, objects or even functions, which could cause unintended side-effects."),(0,i.kt)("p",null,"In typescript, we can communicate the intent of this functions by declaring types for the arguments and the return type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="add.ts"',title:'"add.ts"'},"const add = (a: number, b: number): number => a + b;\n")),(0,i.kt)("p",null,"Now if you tried to call the ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," function with ",(0,i.kt)("inlineCode",{parentName:"p"},'add("hello", "world")'),", you would get a warning in your code editor."),(0,i.kt)("h2",{id:"checking-for-type-errors"},"Checking for type errors"),(0,i.kt)("p",null,"TypeScript is the most useful during development if you use an IDE that supports just-in-time type-checking."),(0,i.kt)("p",null,"I would recommend use ",(0,i.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/"},"Visual Studio Code")," which comes with TypeScript support out of the box. VSCode and TypeScript are both built by Microsoft so they generally work very well together."),(0,i.kt)("h1",{id:"typescript-for-react-native"},"TypeScript for React Native"),(0,i.kt)("p",null,"Let's consider manually typing the following object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const MyItems: MyItemsType = {\n  justString: "Hello",\n  justNumber: 5,\n  stringArray: ["one", "two", "three"],\n  numberArray: [1, 2, 3],\n  objectArray: [{ val: 1 }, { val: 2 }, { val: 3 }],\n  mixedArray: [1, "hello"],\n  funcReturningNothing: () => {},\n  funcWithArgs: (arg1, arg2) => arg1 + arg2,\n};\n\ntype MyItemsType = {\n  justString: string,\n  justNumber: number,\n  stringArray: string[], // or Array<string>\n  numberArray: number[], // or Array<number>\n  objectArray: { val: number }[], // or Array<{ val: number }>\n  mixedArray: (number | string)[], // or Array<number | string>\n  funcReturningNothing: () => void,\n  funcWithArgs: (arg1: number, arg2: number) => number,\n  mightNotExist?: string,\n};\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"you can use ",(0,i.kt)("inlineCode",{parentName:"li"},"?")," to denote an optional type. That means the arg is either as typed or ",(0,i.kt)("inlineCode",{parentName:"li"},"undefined")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void")," means that no return type is set"),(0,i.kt)("li",{parentName:"ul"},"when the type can one of many things, you can use ",(0,i.kt)("inlineCode",{parentName:"li"},"|"),' as an "or" between the options')),(0,i.kt)("h2",{id:"typing-react-components"},"Typing React Components"),(0,i.kt)("p",null,"When typing React components, add ",(0,i.kt)("inlineCode",{parentName:"p"},"React.FC")," after the function name to declare that the return type is a function component."),(0,i.kt)("h3",{id:"in-javascript"},"In JavaScript:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="Greeting.jsx"',title:'"Greeting.jsx"'},'import React from "react";\nimport { Text } from "react-native";\n\nexport const Greeting = () => {\n  return <Text>Hello</Text>;\n};\n')),(0,i.kt)("h3",{id:"in-typescript"},"In TypeScript:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="Greeting.tsx"',title:'"Greeting.tsx"'},'import React from "react";\nimport { Text } from "react-native";\n\nexport const Greeting: React.FC = () => {\n  return <Text>Hello</Text>;\n};\n')),(0,i.kt)("h2",{id:"typing-react-component-props"},"Typing React Component Props"),(0,i.kt)("p",null,"You can type the properties of a component by passing in the type in ",(0,i.kt)("inlineCode",{parentName:"p"},"React.FC<{}>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="User.jsx"',title:'"User.jsx"'},'import React from "react";\nimport { Text } from "react-native";\n\nexport const User = ({ firstName, lastName }) => {\n  return (\n    <Text>\n      {firstName} {lastName}\n    </Text>\n  );\n};\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'title="User.tsx"',title:'"User.tsx"'},'import React from "react";\nimport { Text } from "react-native";\n\ntype UserProps = {\n  firstName: string;\n  lastName: string;\n};\n\nexport const User: React.FC<UserProps> = ({ firstName, lastName }) => {\n  return (\n    <Text>\n      {firstName} {lastName}\n    </Text>\n  );\n};\n')))}l.isMDXComponent=!0}}]);